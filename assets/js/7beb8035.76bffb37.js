"use strict";(globalThis.webpackChunkdocusaurus_book=globalThis.webpackChunkdocusaurus_book||[]).push([[501],{7964(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"kinematics","title":"Chapter 6: Movement: Humanoid Kinematics and Locomotion","description":"This chapter delves into the fundamental principles governing the movement of humanoid robots, focusing on kinematics and locomotion.","source":"@site/docs/06-kinematics.md","sourceDirName":".","slug":"/kinematics","permalink":"/kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/Ameen-0099/humanoid-robotics-book/tree/main/docs/06-kinematics.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 5: Perception: Vision-Language-Action Models","permalink":"/vla"},"next":{"title":"Chapter 7: Manipulation: Grasping and Interaction","permalink":"/manipulation"}}');var i=t(4848),a=t(8453);const s={sidebar_position:6},r="Chapter 6: Movement: Humanoid Kinematics and Locomotion",l={},c=[{value:"Kinematics",id:"kinematics",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Humanoid Locomotion",id:"humanoid-locomotion",level:2},{value:"Common Locomotion Strategies",id:"common-locomotion-strategies",level:3},{value:"Humanoid Gaits",id:"humanoid-gaits",level:3},{value:"Conceptual ZMP Calculation",id:"conceptual-zmp-calculation",level:3},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"chapter-6-movement-humanoid-kinematics-and-locomotion",children:"Chapter 6: Movement: Humanoid Kinematics and Locomotion"})}),"\n",(0,i.jsx)(e.p,{children:"This chapter delves into the fundamental principles governing the movement of humanoid robots, focusing on kinematics and locomotion."}),"\n",(0,i.jsx)(e.h2,{id:"kinematics",children:"Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Kinematics is the study of motion without considering the forces that cause it. In robotics, it primarily deals with the spatial arrangement of the robot's links and joints."}),"\n",(0,i.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Forward kinematics calculates the position and orientation of the robot's end-effector (e.g., a hand) given the angles of its joints."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-mermaid",children:"graph TD;\n    A[Joint Angle 1] --\x3e B[Link 1 Position/Orientation];\n    B --\x3e C[Joint Angle 2];\n    C --\x3e D[Link 2 Position/Orientation];\n    D --\x3e E[End-Effector Position/Orientation];\n"})}),"\n",(0,i.jsx)(e.p,{children:"Here's a simple Python script demonstrating forward kinematics for a 2-DOF (Degrees of Freedom) robotic arm:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\ndef forward_kinematics_2dof(l1, l2, theta1_deg, theta2_deg):\n    """\n    Calculates the end-effector position for a 2-DOF planar robotic arm.\n\n    Args:\n        l1 (float): Length of the first link.\n        l2 (float): Length of the second link.\n        theta1_deg (float): Angle of the first joint in degrees.\n        theta2_deg (float): Angle of the second joint in degrees.\n\n    Returns:\n        tuple: (x, y) coordinates of the end-effector.\n    """\n    theta1_rad = np.deg2rad(theta1_deg)\n    theta2_rad = np.deg2rad(theta2_deg)\n\n    x = l1 * np.cos(theta1_rad) + l2 * np.cos(theta1_rad + theta2_rad)\n    y = l1 * np.sin(theta1_rad) + l2 * np.sin(theta1_rad + theta2_rad)\n    return x, y\n\nif __name__ == "__main__":\n    link1_length = 1.0  # meters\n    link2_length = 0.8  # meters\n    joint1_angle = 30   # degrees\n    joint2_angle = 60   # degrees\n\n    x_ee, y_ee = forward_kinematics_2dof(link1_length, link2_length, joint1_angle, joint2_angle)\n    print(f"End-effector position: x={x_ee:.2f}m, y={y_ee:.2f}m")\n\n    joint1_angle_new = 90\n    joint2_angle_new = -45\n    x_ee_new, y_ee_new = forward_kinematics_2dof(link1_length, link2_length, joint1_angle_new, joint2_angle_new)\n    print(f"New end-effector position: x={x_ee_new:.2f}m, y={y_ee_new:.2f}m")\n'})}),"\n",(0,i.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,i.jsx)(e.p,{children:"Inverse kinematics solves the opposite problem: given a desired end-effector position and orientation, what are the joint angles required to achieve it? This is often more complex and can have multiple solutions or no solutions."}),"\n",(0,i.jsx)(e.h2,{id:"humanoid-locomotion",children:"Humanoid Locomotion"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid locomotion, specifically bipedal walking, is a highly complex task due to the inherent instability of a two-legged stance."}),"\n",(0,i.jsx)(e.h3,{id:"common-locomotion-strategies",children:"Common Locomotion Strategies"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Zero-Moment Point (ZMP)"}),": A widely used concept for achieving stable walking by ensuring that the robot's center of pressure remains within its support polygon."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Pattern Generators"}),": Pre-computed or learned joint trajectories that produce walking motions."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Model Predictive Control (MPC)"}),": Optimizing future movements based on current state and a predictive model of the robot's dynamics."]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"humanoid-gaits",children:"Humanoid Gaits"}),"\n",(0,i.jsx)(e.p,{children:"[Placeholder for a diagram showing different humanoid gaits (e.g., walking, running).]"}),"\n",(0,i.jsx)(e.h3,{id:"conceptual-zmp-calculation",children:"Conceptual ZMP Calculation"}),"\n",(0,i.jsx)(e.p,{children:"Here's a conceptual Python script illustrating a basic zero-moment point (ZMP) calculation for stability:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\ndef calculate_zmp_1d(mass, com_pos, com_acc, gravity):\n    """\n    Conceptual 1D ZMP calculation.\n    ZMP = Center of Mass Position - (CoM Acceleration * CoM Height / Gravity)\n    This is a highly simplified 1D model for illustration.\n\n    Args:\n        mass (float): Total mass of the robot.\n        com_pos (float): Center of mass position (x-coordinate).\n        com_acc (float): Center of mass acceleration (x-coordinate).\n        gravity (float): Acceleration due to gravity.\n\n    Returns:\n        float: The calculated ZMP position (x-coordinate).\n    """\n    # Assuming CoM height is constant and embedded within the formula for simplicity\n    # In reality, ZMP calculation involves more complex dynamics\n    zmp = com_pos - (com_acc / gravity) # Simplified for conceptual understanding\n    return zmp\n\nif __name__ == "__main__":\n    robot_mass = 50.0 # kg\n    com_x_position = 0.1 # meters\n    com_x_acceleration = 0.5 # m/s^2\n    g = 9.81 # m/s^2\n\n    current_zmp = calculate_zmp_1d(robot_mass, com_x_position, com_x_acceleration, g)\n    print(f"Calculated ZMP (1D): {current_zmp:.2f}m")\n\n    # If ZMP is outside the support polygon, the robot is unstable.\n    # For a simple foot, support polygon might be [-0.1m, 0.1m]\n    support_polygon_min = -0.1\n    support_polygon_max = 0.1\n\n    if support_polygon_min <= current_zmp <= support_polygon_max:\n        print("Robot is stable (ZMP within support polygon).")\n    else:\n        print("Robot is unstable (ZMP outside support polygon).")\n'})}),"\n",(0,i.jsx)(e.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,i.jsx)(e.p,{children:"This chapter builds upon our understanding of how VLA models perceive the world from Chapter 5. In the next chapter, we will focus on how robots interact with objects, exploring Manipulation: Grasping and Interaction."})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>r});var o=t(6540);const i={},a=o.createContext(i);function s(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);